### 第一行代码

#### 第一章 开始启程
1. 安卓工程目录
    .gradle和.idea 自动生成的目录，不用修改；
    app 项目中的资源代码等内容；
    build 编译时生成的一些文件；
    gradle 包含gradle wrapper的配置文件，gradle wrapper的方式使用gradle；
    .gitignore git忽略文件；
    build.gradle 项目全局的gradle构建脚本；
    gradle.properties 全局的gradle配置文件；
    gradlew和gradle.bat 用来在命令行界面中执行gradle命令；
    local.properties 用于指定本机中的Android SDK路径；
    setting.gradle 用于指定项目中所引用的模块；
2. App子目录
    build 编译时自动生成的文件；
    libs 第三方jar包放在这里，会自动添加到构建路径里；
    androidTest 用来编写测试用例；
    main 项目代码和资源；
    java 项目代码；
    res 图片、布局、字符串等资源文件，drawable图片，layout布局，values字符串；
    AndroidManifest.xml 项目的配置文件，所有组件都需要注册在里面，还可以给App添加权限说明；
    test 单元测试的测试用例；
    .gitignore 模块内的git忽略文件；
    build.gradle App模块的gradle构建脚本，指定项目构建的相关配置；
    proguard-rules.pro 用于指定项目代码的混淆规则，防止被反编译破解；
3. AndroidManifest.xml里的Activity的配置`<action android:name="android.intent.action.MAIN" /><category android:name="android.intent.category.LAUNCHER" />`表示这是项目的主Activity，点击图标，首先启动这个activity
4. Android程序设计讲究逻辑和视图分离，不推荐在活动中直接编写界面，通用做法是在布局文件中编写界面，在活动中引用进来；
5. res目录下的资源文件，drawable放图片，mipmap放应用图标，values用来放字符串、样式、颜色等配置的，layout用来放布局文件；多个mipmap文件夹为了兼容各种设备；代码中用R.string.hello_wrold引用字符串、图片、图标、布局文件，XML中用@string/hello_world引用字符串、图片、图标、布局文件；
6. 工程中的build.gradle，repositories闭包声明仓库地址，jcenter，google都是代码仓库；dependencies闭包中用classpath声明一个gradle插件，用于构建Android项目；
7. 模块中的build.gradle，第一行用来区分是应用程序还是库，com.android.application，com.andriod.library；compileSdkVersion项目编译版本，buildToolsVersion构建工具版本；applicationId包名，minSdkVersion最低兼容的Android系统版本，targetSdkVersion做过充分测试的版本，versionCode版本号，versionName版本名；minifyEnabled代码混淆，proguardFiles指定代码混淆规则；
8. dependencies库依赖，implementation/api/compile fillTree声明本地依赖，将libs目录下的.jar文件都添加到项目构建路径中；implementation/api/compile声明远程依赖；api；provided引入的包只参与编译，不参与打包；
9. 使用logt加tab即可生成类名TAG常量，logd加tab生成Log.d(TAG，"方法名：")；

#### 第二章 探究活动
1. res-menu-main添加右上角菜单；重写onCreateOptionsMenu方法，getMenuInflater得到MenuInflater对象，调用inflate()方法为当前活动创建菜单；inflate方法第一个参数指定资源文件名，第二个参数指定添加菜单的位置；重写onOptionsItemSelected方法，实现菜单点击事件；
2. Intent用于启动活动、启动服务和发送广播等场景；显式Intent，通过构造函数创建Intent，在startActivity等方法中传入创建的Intent进行跳转；隐式Intent不指定要启动的具体活动，而是指定要启动的活动的action和category，系统来启动合适的活动；隐式Intent，可以用来启动其他程序的活动；
3. Intent.putExtra用于传递数据到下个页面；startActivityForResult和onActivityResult方法传递数据到上个页面；
4. 每个活动在生命周期中会有4中状态；运行状态，位于栈顶的活动；暂停状态，不在栈顶但是仍然可见的活动；停止状态，不在栈顶并且不可见的活动；销毁状态，不在栈中的活动；
5. 活动的生命周期，onCreate活动第一次被创建时调用，onStart活动不可见变为可见时调用，onResume活动准备好和用户进行交互时调用；onPause系统准备启动或回复另一个活动时调用，onStop活动完全不可见时调用；onDestroy活动被销毁之前调用；onRestart活动有停止状态变为运行状态之前调用；
6. 活动的启动模式，standard默认启动模式，每次启动活动都会创建新的活动并入栈；singleTop启动活动时，如果栈顶是该活动，则直接使用，不会创建新的活动实例；singleTask启动活动时，会从栈中检查是否有该活动的实例，如果有直接返回，并把该活动之上的所有活动统统出栈；singleInstance开启一个新的返回栈来管理活动；

#### 第三章 UI开发的点点滴滴
1. TextView（Label），layout_width和layout_height指定控件的宽高，值为match_parent父视图宽度或高度，wrap_content内容宽度或高度；gravity指定文字对齐方式；textSize文字大小，单位sp，textColor文字颜色；
2. Button，文字默认大写，可以用textAllCaps控制；可以通过匿名内部类的方式添加监听器（block），也可以用接口方式注册（delegate）；
3. EditText（TextField），hint（placeholder）输入框提示文本；maxLines指定最大行数，超过滑动；
4. ImageView，src在xml中设置图片路径，setImageResource在java中设置资源路径；
5. ProgressBar，用于在界面上显示进度条，visibility用于设置进度条显示和隐藏，visible/invisible/gone，可见/不可见/隐藏，gone进度条不可见也不占用空间；
6. AlertDialog，弹出对话框，位于视图最上层，用于提示非常重要的内容或警告；
7. ProgressDialog，带有进度条的对话框，setCancelable设置是否可以通过返回键隐藏对话框；
8. layout_gravity指定控件在布局中的对齐方式；layout_weight指定控件占父控件的比例，设置width或height为0dp；layout_alignParentStart/layout_alignParentLeft，layout_alignParentEnd/layout_alignParentRight，layout_alignParentTop，layout_alignParentBottom和父布局的左右上下对齐；layout_centerInParent，layout_centerHorizontal，layout_centerVertical，居中、水平居中、垂直居中在父视图布局；
9. layout_above，layout_below相对其他组件上下对齐；layout_toLeftOf/layout_toStartOf，layout_toRightOf/layout_toEndOf相对其他组件左右对齐；
10. View是基类，所有的控件都是view的子类，所有的布局也是view的子类，布局里面可以放其他控件，是一个容器；
11. `LayoutInflater.from(context).inflate(R.layout.title, this);`动态加载布局文件，inflate（布局文件名，布局加载到的父布局，是否添加到父布局）；
12. ListView（类似tableview），ListView中的数据要用Adapter来传递（类似DataSource）；adapter中的getView（类似cellforrowatindexpath），给组件设置数据；使用convertview和viewHolder来实现重用和缓存，提高ListView性能；
13. RecycleView（类似collectionview），LinearLayoutManager水平或垂直布局；StaggeredGridLayoutManager瀑布流布局，构造函数（列数，方向）；有单独的adapter和viewholder来处理和显示数据，可以继承并修改；
14. 点9图绘制，左上表示会被拉伸的区域，右下表示内容会被放置的区域；按Shift拖动，清楚选择区域；
15. RecyclerView.Adapter的notifyItemInserted通知有数据插入，RecyclerView的scrollToPosition滚动到指定位置；

#### 第四章 探究碎片
1. 在fragment标签中使用android:name来指定碎片的类名；碎片可以在运行时动态添加，使用FragmentTransaction实现；findFragmentById在活动动获取碎片实例，getActivity在碎片中获取活动实例；
2. 根据屏幕动态加载布局，屏幕大小small、normal、large、xlarge，分辨率ldpi、mdpi、hdpi、xhdpi、xxhdpi，方向land、port；可以指定最小宽度限定符sw，超过时会加载；
3. activity的xml中引入fragment标签，fragment通过name指定Fragment类，最终显示fragment到activity中，绑定Fragment和Activity；碎片的onCreateView和onActivityCreated声明周期方法，在里面处理view和activity相关的操作；
4. fragment声明周期，onAttach活动和碎片建立关联，oncreateView为碎片创建View，onActivityCreated碎片关联的活动建立完成，onDestroyview碎片关联的view被移除，onDetach碎片和活动解除关联；

#### 第五章 详解广播机制
1. 新建类继承BroadcastReceiver，重写onreceive方法，接收到广播之后的操作；新建IntentFilter实例，调用addaction方法添加需要监听的广播名称；registReceiver注册广播，将广播和BroadcastReceiver关联；销毁时要unregisterReceiver来取消注册广播；
2. 静态注册广播，新建BroadcastReceiver类，在Receiver标签中添加intent-filter标签指定要接受的广播名称；广播的onreceive方法中不能进行耗时操作，不能开启新线程；
3. 新建intent，包含广播名称，设置component包名和类名，intent.setComponent(new ComponentName("com.example.myfirstapp", "com.example.myfirstapp.MyBroadcastReceiver"))用sendbroadcast发送广播；
4. 
